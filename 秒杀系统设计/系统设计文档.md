# 实现原理
Apollo 的核心挑战是：
如何应对突然出现的数百倍高并发访问压力？
1. 缓存 + 预热。使用CDN， redis，浏览器/app本地缓存等分摊请求到后台服务器和DB的流量负载
2. 异步处理。对于无法用缓存处理的写请求，则采用异步处理的方式，处理完成后通知用户写请求的处理结果。
3. 用户维度限流。

如何保证用户只有在秒杀开始时才能下单购买秒杀商品？
1. 后端服务对商品秒杀活动开始时间判断，开始前禁止拦截下单请求。
2. 在秒杀开始前，前端禁用对秒杀商品的下单按钮
3. 在秒杀开始后，详情页开始下发秒杀开始的secret，只有带有该secret参数的下单请求才是正常的请求。

# 概要设计

![Resilience](./../pictures/flash_sale/brief.drawio.png)

Detail Service: 提供秒杀商品详情查询服务

Order Service: 提供商品下单服务。
# 详细设计

## 存储设计
数据模型如下：
![Resilience](./../pictures/flash_sale/er.drawio.png)

MySQL保存上面er图中描述的活动信息，商品的信息，以及活动与商品的映射关系。
S3则存储商品图片，视频等信息。

因为要是保障高可用和高并发，所以选一主二从的方式来部署MySQL。而秒杀的数据规模不会很大，所以单库单表应该就够用了，存储设计如下：
![Resilience](./../pictures/flash_sale/db.drawio.png)

## Admin
![Resilience](./../pictures/flash_sale/admin.drawio.png)

通过调用Admin服务来设置秒杀活动。因为流量不高，采用直接写DB的方式。 对于运营设置的秒杀活动的图片，视频等，由前端直接保存到S3中，MySQL只需要保存图片和视频存储id。

## Detail Service
![Resilience](./../pictures/flash_sale/detail_service.drawio.png)

Load service：在活动开始前1h，Load service会主动将秒杀商品图片、视频等数据量较大的信息事先加载到CDN中，同时，也会将MySQL中相关的秒杀商品信息加载redis cluster缓存中。

Detail Service：负责查询相关的秒杀活动信息，先从Redis Cluster中获取，如果没有，则会通过cache aside的方式从MySQL中获取，并写入Redis Cluster中。

S3： 保存秒杀商品的图片、视频等数据量较大的信息。

商品详情查询流程：
1. 用户通过网关请求秒杀商品信息，Detail Service收到请求后，查询Redis cluster，获取该商品信息，如果Redis中没有则会去MySQL中获取，并缓存到Redis。
2. 用户获取到秒杀商品信息后，会将商品的图片ID、视频ID请求CDN，如果CDN中有该图片和视频，则直接返回，前端将该图片、视频渲染。否则，继续下一步
3. CDN访问S3获取对应的图片和视频，并将其缓存当CDN中，然后返回给前端。

## Order Service
![Resilience](./../pictures/flash_sale/order_service.drawio.png)

Order service：通过责任链模式构建管道来处理用户下单请求：下单去重 ->  库存校验 -> 扣减库存 -> 发送到MQ； 同时也给前端提供了一个API来查询当前用户的订单状态（是否抢购成功）。

Order Handler：根据用户请求，创建订单，如果db中库存不够，则创建失败。创建订单 与 在db中扣减库存需要事务保障。

Redis cluster：保存秒杀商品的当前库存，Order service会根据该库存来判断用户是否秒杀成功，如果库存已经<=0, 则会直接返回告诉用户，秒杀失败。如果库存>0, 则加锁并扣减库存。
为了减少Redis单机压力，可以将秒杀商品库存的保存在多个key上，每个redis key保存一部分库存。

下单流程：
1. 用户下单，Order service从Redis Cluster中获取该秒杀商品的剩余库存，如果剩余库存 <= 0, 则返回下单失败给用户。否则，继续执行下一步
2. 申请分布式锁，获取并判断库存，如果库存 <= 0,则抢购失败；否则请求包装成消息发送到MQ中，并扣减库存，同时返回给前端，让其给用户展示等待页面，并过几秒来查询商品秒杀结果。
3. Order Handler调用MySQL执行扣减库存， 以及创建订单操作，这两步需事务执行。如果扣减库存失败（库存不能 < 0), 则创建失败的订单。
4. 前端等待几秒后（比如2s），再项Order Service发起用户订单状态查询，Order Service根据DB中该用户的订单状态返回告诉前端是否抢购成功的结果。

## 总体架构
![Resilience](./../pictures/flash_sale/final.drawio.png)

API Gateway: 限流、路由、安全、权限检查等。

Redis Cluster: 1. 缓存秒杀商品短期内不会频繁变化的的部分。 2. 缓存秒杀商品频繁变化的stock （分多个key存储）。

# 设计小结


# 关键问题
Q1. 前端如何识别一个商品是否为秒杀商品？
通过给商品id上加秒杀tag