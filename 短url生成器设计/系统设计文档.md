# 概要设计
## 实现原理
短 URL 生成器的设计核心就是短 URL 的生成，即长 URL 通过某种函数，计算得到一个 6 个字符的短 URL。短 URL 有几种不同的生成算法。
### 单项散列函数生成短 URL
通常的设计方案是，将长 URL 利用 MD5 或者 SHA256 等单项散列算法，进行 Hash 计算，得到 128bit 或者 256bit 的 Hash 值。然后对该 Hash 值进行 Base64 编码，得到 22 个或者 43 个 Base64 字符，再截取前面的 6 个字符，就得到短 URL 了，如图。
![Resilience](./../pictures/short_url3.png)
但是这样得到的短 URL，可能会发生 Hash 冲突，即不同的长 URL，计算得到的短 URL 是相同的（MD5 或者 SHA256 计算得到的 Hash 值几乎不会冲突，但是 Base64 编码后再截断的 6 个字符有可能会冲突）

所以在生成的时候，需要先校验该短 URL 是否已经映射为其他的长 URL，如果是，那么需要重新计算（换单向散列算法，或者换 Base64 编码截断位置）。重新计算得到的短 URL 依然可能冲突，需要再重新计算

但是这样的冲突处理需要多次到存储中查找 URL，无法保证 Fuxi 的性能要求。
### 自增长短URL
一种免冲突的算法是用自增长自然数来实现，即维持一个自增长的二进制自然数，然后将该自然数进行 Base64 编码即可得到一系列的短 URL。这样生成的的短 URL 必然唯一，而且还可以生成小于 6 个字符的短 URL，比如自然数 0 的 Base64 编码是字符“A”，就可以用 http://1.cn/A 作为短 URL。

但是这种算法将导致短 URL 是可猜测的，如果某个应用在某个时间段内生成了一批短 URL，那么这批短 URL 就会集中在一个自然数区间内。只要知道了其中一个短 URL，就可以通过自增（以及自减）的方式请求访问其他 URL。Fuxi 的需求是不允许短 URL 可预测。

### 随机数短URL
预生成短 URL 的算法可以采用随机数来实现，6 个字符，每个字符都用随机数产生（用 0~63 的随机数产生一个 Base64 编码字符）。
为了避免随机数产生的短 URL 冲突，需要在预生成的时候检查该 URL 是否已经存在（用布隆过滤器检查）。

## 简要总体架构
![Resilience](./../pictures/short_url.drawio.png)

# 详细设计
分布式系统的核心是数据，所以我们从数据存储开始。
## 存储设计
数据模型 
|short_url|origin_url|
|----|----|
|abcdef|https:baidu.com/tengxunshipingxxxx|


预计每月新生成短 URL 5 亿条，短 URL 有效期 2 年，那么总URL数量为120 亿。因此可以选择MySQL分库分表，
也可以选择 NoSQL，eg:TiDB。
假设我们选择DB，则分库50，每个库200个表，这样每个表中有 120亿/（50*200）= 120w条数据。
为了实现数据存储的高可用，我们对数据库采用了一主二从的部署方式。

![Resilience](./../pictures/db.drawio.png)

## url generate service
基于服务高性能的考虑，采用预生成的方式来快速得到可用的短url。

预先生成一批没有冲突的短 URL 字符串，当外部请求输入长 URL 需要生成短 URL 的时候，直接从预先生成好的短 URL 字符串池中获取一个即可。

预生成短 URL 的算法可以采用随机数来实现，6 个字符，每个字符都用随机数产生（用 0~63 的随机数产生一个 Base64 编码字符）。
为了避免随机数产生的短 URL 冲突，需要在预生成的时候检查该 URL 是否已经存在（用布隆过滤器检查）。
因为预生成短 URL 是离线的，所以这时不会有性能方面的问题。甚至，可以在上线之前就已经生成全部需要的 144 亿条短 URL 并存储在文件系统中（预估需要短 URL120 亿，Fuxi 预生成的时候进行了 20% 的冗余，即 144 亿。）

写的QPS并不高，直接将一条一条记录写入DB中就行

![Resilience](./../pictures/generate.drawio.png)

## query service

采用redis集群codis来缓存url数据，利用CDC数据分发技术同步DB中的数据变更同步到cache中，

每条短 URL 数据库记录大约 1KB，那么需要总存储空间 12TB（不含数据冗余备份）。Redis容量选用200G的，（采用LRU算法淘汰非热门数据）。


因为QPS/WPS = 100, 所以同时访问同一个url的并发量不小，采用请求合并single flight技术来访问缓存，缓存不存在时回源读取DB，并写入缓存。

获取到原始url后， 返回HTTP重定向响应，让用户可以重定向到原始URL。

![Resilience](./../pictures/short_url_query.drawio.png)

## admin
管理端流量较少，查询简单，直接查询DB。
同时，启动一个reaper线程，定期删除过期的url。
![Resilience](./../pictures/admin.drawio.png)

## 总体架构
![Resilience](./../pictures/final.drawio.png)

# 小结